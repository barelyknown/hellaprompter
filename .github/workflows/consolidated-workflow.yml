name: Build and Deploy

on:
  push:
    branches: [ main ]
  workflow_dispatch:

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: write
  pages: write
  id-token: write
  deployments: read

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      twitter_token: ${{ steps.post-to-x.outputs.TWITTER_REFRESH_TOKEN }}
      token_updated: ${{ steps.post-to-x.outputs.token_updated || steps.check-token.outputs.token_updated }}
    steps:
      - name: Checkout 🛎️
        uses: actions/checkout@v3
        with:
          fetch-depth: 0 # Fetch all history for all branches and tags
          lfs: true # Include Git LFS files
      
      - name: Setup Node.js 🔧
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
          
      - name: Install Dependencies 📦
        run: npm ci
        
      - name: Format Completions 📝
        run: npm run format-completions
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          
      - name: Generate Illustrations 🖼️
        run: npm run generate-illustrations
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          IDEOGRAM_API_KEY: ${{ secrets.IDEOGRAM_API_KEY }}
          
      - name: Commit formatted completions and illustrations if any changes 💾
        id: commit-changes
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          # Check if there are any changes to commit
          if [[ -n $(git status --porcelain prompts) ]]; then
            # Add all changed files in prompts directory
            git add prompts/*/completion.md || true
            git add prompts/*/*.png || true
            git add prompts/*/metadata.json || true
            git commit -m "Auto-format completions and generate illustrations" || true
            git push
            echo "changes_committed=true" >> $GITHUB_OUTPUT
          else
            echo "No changes to commit"
            echo "changes_committed=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Fetch latest changes after commit 🔄
        run: git pull
        
      - name: Build site 🏗️
        run: |
          npm run build
      
      - name: Check if token file directory exists
        run: |
          mkdir -p twitter_tokens

      - name: Check if token was updated
        id: check-token
        run: |
          if [ -f "twitter_tokens/new_refresh_token.txt" ]; then
            echo "token_updated=true" >> $GITHUB_OUTPUT
          else
            echo "token_updated=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Deploy to GitHub Pages 🚀
        uses: JamesIves/github-pages-deploy-action@v4
        with:
          folder: dist
          branch: gh-pages
          
      - name: Wait for GitHub Pages Deployment to Complete
        uses: actions/github-script@v6
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            
            console.log(`Waiting for GitHub Pages deployment to complete for ${owner}/${repo}...`);
            
            // Function to get the latest deployment
            async function getLatestDeployment() {
              try {
                const deployments = await github.rest.repos.listDeployments({
                  owner,
                  repo,
                  environment: 'github-pages'
                });
                
                if (deployments.data.length === 0) {
                  return null;
                }
                
                return deployments.data[0];
              } catch (error) {
                console.log(`Error getting deployments: ${error.message}`);
                return null;
              }
            }
            
            // Function to get deployment status
            async function getDeploymentStatus(deploymentId) {
              try {
                const statuses = await github.rest.repos.listDeploymentStatuses({
                  owner,
                  repo,
                  deployment_id: deploymentId
                });
                
                if (statuses.data.length === 0) {
                  return null;
                }
                
                return statuses.data[0];
              } catch (error) {
                console.log(`Error getting deployment status: ${error.message}`);
                return null;
              }
            }
            
            // Poll for deployment completion
            let deployment = null;
            let status = null;
            const maxAttempts = 30;
            const pollInterval = 10000; // 10 seconds
            
            // Wait for deployment to be created or found
            for (let i = 0; i < maxAttempts; i++) {
              console.log(`Looking for deployment (attempt ${i+1}/${maxAttempts})...`);
              deployment = await getLatestDeployment();
              
              if (deployment) {
                console.log(`Found deployment with ID: ${deployment.id}`);
                break;
              }
              
              await new Promise(resolve => setTimeout(resolve, pollInterval));
            }
            
            if (!deployment) {
              console.log('Warning: No GitHub Pages deployment found after maximum attempts');
              console.log('Will proceed with post-deployment tasks anyway');
              return;
            }
            
            // Wait for deployment to complete
            for (let i = 0; i < maxAttempts; i++) {
              console.log(`Checking deployment status (attempt ${i+1}/${maxAttempts})...`);
              status = await getDeploymentStatus(deployment.id);
              
              if (status) {
                console.log(`Current status: ${status.state}`);
                
                if (status.state === 'success') {
                  console.log('Deployment completed successfully!');
                  break;
                } else if (status.state === 'failure' || status.state === 'error') {
                  console.log(`Warning: Deployment failed with status: ${status.state}`);
                  console.log('Will proceed with post-deployment tasks anyway');
                  return;
                }
              }
              
              await new Promise(resolve => setTimeout(resolve, pollInterval));
            }
            
            if (!status || status.state !== 'success') {
              console.log('Warning: Deployment did not complete successfully within the timeout period');
              console.log('Will proceed with post-deployment tasks anyway');
              return;
            }
            
            console.log('GitHub Pages deployment is now complete and live!');

      - name: Post to X (after deployment) 🐦
        id: post-to-x
        env:
          TWITTER_CLIENT_ID: ${{ secrets.TWITTER_CLIENT_ID }}
          TWITTER_CLIENT_SECRET: ${{ secrets.TWITTER_CLIENT_SECRET }}
          TWITTER_REFRESH_TOKEN: ${{ secrets.TWITTER_REFRESH_TOKEN }}
        run: |
          # Run a script to post all eligible prompts to X
          echo "Posting eligible prompts to X after site deployment..."
          npm run post-all-to-x
          
          # If a new token was generated, read it and set as output
          if [ -f "twitter_tokens/new_refresh_token.txt" ]; then
            # Set the refresh token output
            echo "TWITTER_REFRESH_TOKEN=$(cat twitter_tokens/new_refresh_token.txt)" >> $GITHUB_OUTPUT
            # Set token_updated to true to trigger the update-token job
            echo "token_updated=true" >> $GITHUB_OUTPUT
            echo "Token updated and outputs set for update-token job"
          fi
      
      - name: Commit xPostUrl updates to metadata.json 💾
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          # First pull any changes that might have been made
          git pull origin main
          
          # Check for changes in metadata.json files specifically
          if [[ -n $(git status --porcelain prompts/*/metadata.json) ]]; then
            # Add all changed metadata files
            git add prompts/*/metadata.json
            git commit -m "Update xPostUrl in metadata.json after posting to X" || true
            # Push with upstream set explicitly
            git push -u origin main
            echo "Committed and pushed xPostUrl updates"
          else
            echo "No metadata changes to commit"
          fi

  update-token:
    needs: build
    if: needs.build.outputs.token_updated == 'true'
    uses: ./.github/workflows/store-twitter-token.yml
    with:
      token: ${{ needs.build.outputs.twitter_token }}
    secrets:
      GH_PAT: ${{ secrets.GH_PAT }}