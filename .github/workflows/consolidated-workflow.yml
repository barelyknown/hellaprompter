name: Build and Deploy

on:
  push:
    branches: [ main ]
  workflow_dispatch:

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: write
  pages: write
  id-token: write
  deployments: read

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      twitter_token: ${{ steps.post-to-x.outputs.TWITTER_REFRESH_TOKEN }}
      token_updated: ${{ steps.post-to-x.outputs.token_updated || steps.check-token.outputs.token_updated }}
    steps:
      - name: Checkout 🛎️
        uses: actions/checkout@v3
        with:
          fetch-depth: 0 # Fetch all history for all branches and tags
          lfs: true # Include Git LFS files
      
      - name: Setup Node.js 🔧
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
          
      - name: Install Dependencies 📦
        run: npm ci
        
      - name: Format Completions 📝
        run: npm run format-completions
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          
      - name: Generate Illustrations 🖼️
        run: npm run generate-illustrations
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          IDEOGRAM_API_KEY: ${{ secrets.IDEOGRAM_API_KEY }}
          
      - name: Commit formatted completions and illustrations if any changes 💾
        id: commit-changes
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          # Check if there are any changes to commit
          if [[ -n $(git status --porcelain prompts) ]]; then
            # Add all changed files in prompts directory
            git add prompts/*/completion.md || true
            git add prompts/*/*.png || true
            git add prompts/*/metadata.json || true
            git commit -m "Auto-format completions and generate illustrations" || true
            git push
            echo "changes_committed=true" >> $GITHUB_OUTPUT
          else
            echo "No changes to commit"
            echo "changes_committed=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Fetch latest changes after commit 🔄
        run: git pull
        
      - name: Build site 🏗️
        run: |
          npm run build
      
      - name: Check if token file directory exists
        run: |
          mkdir -p twitter_tokens

      - name: Check if token was updated
        id: check-token
        run: |
          if [ -f "twitter_tokens/new_refresh_token.txt" ]; then
            echo "token_updated=true" >> $GITHUB_OUTPUT
          else
            echo "token_updated=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Deploy to GitHub Pages 🚀
        uses: JamesIves/github-pages-deploy-action@v4
        with:
          folder: dist
          branch: gh-pages
          
      - name: Wait for GitHub Pages Deployment to Complete
        uses: actions/github-script@v6
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const sha = context.sha;
            
            console.log(`Waiting for GitHub Pages deployment to complete for ${owner}/${repo} at commit ${sha}...`);
            
            // Get the start time of this workflow run
            const workflowStartTime = new Date().getTime() - (5 * 60 * 1000); // 5 minutes ago to be safe
            const workflowStartTimeIso = new Date(workflowStartTime).toISOString();
            console.log(`Looking for deployments created after: ${workflowStartTimeIso}`);
            
            // Function to get the latest deployment matching our criteria
            async function getCurrentDeployment() {
              try {
                // Get all GitHub Pages deployments
                const deployments = await github.rest.repos.listDeployments({
                  owner,
                  repo,
                  environment: 'github-pages'
                });
                
                if (deployments.data.length === 0) {
                  return null;
                }
                
                // First look for a deployment that matches the current commit SHA
                const currentShaDeployment = deployments.data.find(d => 
                  d.sha === sha || 
                  (d.description && d.description.includes(sha))
                );
                
                if (currentShaDeployment) {
                  console.log(`Found deployment matching current commit SHA: ${sha}`);
                  return currentShaDeployment;
                }
                
                // If no SHA match, look for a recent deployment created after our workflow started
                const recentDeployments = deployments.data.filter(d => {
                  const deployCreatedAt = new Date(d.created_at).getTime();
                  return deployCreatedAt > workflowStartTime;
                });
                
                if (recentDeployments.length > 0) {
                  console.log(`Found ${recentDeployments.length} deployments created after workflow started`);
                  // Sort by created_at descending to get the most recent
                  recentDeployments.sort((a, b) => 
                    new Date(b.created_at).getTime() - new Date(a.created_at).getTime()
                  );
                  return recentDeployments[0];
                }
                
                // Fall back to the most recent deployment
                console.log('No matching deployment found, using most recent deployment (this may be from a previous run)');
                return deployments.data[0];
              } catch (error) {
                console.log(`Error getting deployments: ${error.message}`);
                return null;
              }
            }
            
            // Function to get deployment status
            async function getDeploymentStatus(deploymentId) {
              try {
                const statuses = await github.rest.repos.listDeploymentStatuses({
                  owner,
                  repo,
                  deployment_id: deploymentId
                });
                
                if (statuses.data.length === 0) {
                  return null;
                }
                
                return statuses.data[0];
              } catch (error) {
                console.log(`Error getting deployment status: ${error.message}`);
                return null;
              }
            }
            
            // Function to check GitHub Pages build status directly
            async function getGitHubPagesStatus() {
              try {
                const pagesInfo = await github.rest.repos.getPages({
                  owner,
                  repo
                });
                
                if (pagesInfo && pagesInfo.data && pagesInfo.data.status) {
                  return pagesInfo.data.status;
                }
                return null;
              } catch (error) {
                console.log(`Error getting Pages status: ${error.message}`);
                return null;
              }
            }
            
            // Poll for deployment completion
            let deployment = null;
            let status = null;
            let pagesStatus = null;
            const maxAttempts = 40; // Increase max attempts to allow for longer queue times
            const pollInterval = 15000; // 15 seconds between checks
            
            // Wait for deployment to be created or found
            console.log('Starting to look for the current GitHub Pages deployment...');
            for (let i = 0; i < maxAttempts; i++) {
              console.log(`Looking for deployment (attempt ${i+1}/${maxAttempts})...`);
              
              // Check both the deployment API and the Pages API
              deployment = await getCurrentDeployment();
              pagesStatus = await getGitHubPagesStatus();
              
              if (pagesStatus) {
                console.log(`Current GitHub Pages status: ${pagesStatus}`);
              }
              
              if (deployment) {
                console.log(`Found deployment with ID: ${deployment.id}`);
                console.log(`Deployment created at: ${deployment.created_at}`);
                console.log(`Deployment SHA: ${deployment.sha}`);
                break;
              }
              
              // If we've been looking for a while and still don't have a deployment,
              // check if Pages status indicates a build is in progress or queued
              if (i >= 10 && pagesStatus && (pagesStatus === 'building' || pagesStatus === 'queued')) {
                console.log('GitHub Pages is building or queued, continuing to wait for deployment...');
                // Keep waiting
              } else if (i >= 15 && !deployment) {
                // After a significant wait with no deployment found, break and try to
                // check deployment status anyway (may be a visibility issue with the API)
                console.log('No deployment found after significant wait. Will check Pages status directly.');
                break;
              }
              
              await new Promise(resolve => setTimeout(resolve, pollInterval));
            }
            
            // Even if no deployment was found, check the GitHub Pages status
            if (!deployment) {
              pagesStatus = await getGitHubPagesStatus();
              if (pagesStatus) {
                console.log(`Current GitHub Pages status: ${pagesStatus}`);
                if (pagesStatus === 'built') {
                  console.log('GitHub Pages reports as built, proceeding with post-deployment tasks');
                  return;
                }
              }
              
              console.log('Warning: No GitHub Pages deployment found after maximum attempts');
              console.log('Will check periodically and proceed when possible');
              
              // Continue to poll the Pages status API directly
              for (let i = 0; i < 10; i++) {
                await new Promise(resolve => setTimeout(resolve, pollInterval));
                pagesStatus = await getGitHubPagesStatus();
                if (pagesStatus) {
                  console.log(`Pages status (attempt ${i+1}/10): ${pagesStatus}`);
                  if (pagesStatus === 'built') {
                    console.log('Pages status indicates the site is built. Proceeding.');
                    return;
                  }
                }
              }
              
              console.log('Could not confirm Pages deployment. Proceeding with caution.');
              return;
            }
            
            // Wait for deployment to complete
            console.log(`Monitoring deployment ID ${deployment.id} for completion...`);
            for (let i = 0; i < maxAttempts; i++) {
              console.log(`Checking deployment status (attempt ${i+1}/${maxAttempts})...`);
              status = await getDeploymentStatus(deployment.id);
              
              // Also check the Pages status API
              pagesStatus = await getGitHubPagesStatus();
              if (pagesStatus) {
                console.log(`GitHub Pages status: ${pagesStatus}`);
              }
              
              if (status) {
                console.log(`Deployment status: ${status.state}`);
                
                if (status.state === 'success') {
                  console.log('Deployment completed successfully!');
                  break;
                } else if (status.state === 'failure' || status.state === 'error') {
                  console.log(`Warning: Deployment failed with status: ${status.state}`);
                  console.log('Will continue to check Pages status directly');
                  
                  // If deployment API shows failure but Pages status is good, proceed anyway
                  if (pagesStatus === 'built') {
                    console.log('Pages API reports site is built despite deployment API reporting failure');
                    console.log('Will proceed with post-deployment tasks');
                    return;
                  }
                  
                  // Otherwise, keep polling the Pages status
                  break;
                }
              }
              
              // If no status but Pages shows built, proceed
              if (!status && pagesStatus === 'built') {
                console.log('No deployment status, but Pages API reports site is built');
                console.log('Will proceed with post-deployment tasks');
                return;
              }
              
              await new Promise(resolve => setTimeout(resolve, pollInterval));
            }
            
            // Final check - if we don't have success status but Pages API says built
            if ((!status || status.state !== 'success') && pagesStatus === 'built') {
              console.log('Pages API reports site is built, proceeding despite deployment status');
              return;
            }
            
            if (!status || status.state !== 'success') {
              console.log('Warning: Deployment did not complete successfully within the timeout period');
              console.log('Will proceed with post-deployment tasks cautiously');
              return;
            }
            
            console.log('GitHub Pages deployment is now complete and live!');

      - name: Post to X (after deployment) 🐦
        id: post-to-x
        env:
          TWITTER_CLIENT_ID: ${{ secrets.TWITTER_CLIENT_ID }}
          TWITTER_CLIENT_SECRET: ${{ secrets.TWITTER_CLIENT_SECRET }}
          TWITTER_REFRESH_TOKEN: ${{ secrets.TWITTER_REFRESH_TOKEN }}
        run: |
          # Run a script to post all eligible prompts to X
          echo "Posting eligible prompts to X after site deployment..."
          npm run post-all-to-x
          
          # If a new token was generated, read it and set as output
          if [ -f "twitter_tokens/new_refresh_token.txt" ]; then
            # Set the refresh token output
            echo "TWITTER_REFRESH_TOKEN=$(cat twitter_tokens/new_refresh_token.txt)" >> $GITHUB_OUTPUT
            # Set token_updated to true to trigger the update-token job
            echo "token_updated=true" >> $GITHUB_OUTPUT
            echo "Token updated and outputs set for update-token job"
          fi
      
      - name: Commit xPostUrl updates to metadata.json 💾
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          # First pull any changes that might have been made
          git pull origin main
          
          # Check for changes in metadata.json files specifically
          if [[ -n $(git status --porcelain prompts/*/metadata.json) ]]; then
            # Add all changed metadata files
            git add prompts/*/metadata.json
            git commit -m "Update xPostUrl in metadata.json after posting to X" || true
            # Push with upstream set explicitly
            git push -u origin main
            echo "Committed and pushed xPostUrl updates"
          else
            echo "No metadata changes to commit"
          fi

  update-token:
    needs: build
    if: needs.build.outputs.token_updated == 'true'
    uses: ./.github/workflows/store-twitter-token.yml
    with:
      token: ${{ needs.build.outputs.twitter_token }}
    secrets:
      GH_PAT: ${{ secrets.GH_PAT }}